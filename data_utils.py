# -*- coding: utf-8 -*-
"""data_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AG5x8u6U3UR6abLFR908sbgaQBVeyXhn
"""

"""
Утилиты для работы с данными.
"""

import json
from typing import Dict, List, Tuple, Any
from datasets import load_dataset
from tqdm import tqdm
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM


def load_counterfact_data(filepath: str = "data/counterfact.json") -> List[Dict[str, Any]]:
    """Загрузка данных из counterfact.json."""
    with open(filepath, 'r') as f:
        data = json.load(f)
    return data


def format_fact_prompt(prompt_data: Dict[str, Any], system_prompt: str = None) -> Tuple[str, str]:
    """
    Форматирование промпта для факт-эдитинга.

    Args:
        prompt_data: Словарь с данными о факте
        system_prompt: Системный промпт

    Returns:
        Кортеж (positive_prompt, negative_prompt)
    """
    if system_prompt is None:
        system_prompt = "You are a helpful assistant who answers questions directly."

    BOS_TOKEN = "<s>"
    B_INST = "[INST]"
    E_INST = "[/INST]"
    B_SYS = "<<SYS>>"
    E_SYS = "<</SYS>>"

    question = prompt_data['question']
    positive = prompt_data['positive']
    negative = prompt_data['negative']

    SYSTEM_BLOCK = f"{B_SYS}\n{system_prompt}\n{E_SYS}"
    user_prompt = f"{question}\n\nChoices: (A): {positive} (B): {negative}"
    final_prompt = f"{BOS_TOKEN} {B_INST} \n{SYSTEM_BLOCK}\n\n{user_prompt} {E_INST} "

    return (final_prompt + "(A)", final_prompt + "(B)")


def prepare_counterfact_pairs(data: List[Dict[str, Any]]) -> List[Tuple[str, str]]:
    """
    Подготовка пар промптов из counterfact данных.
    """
    prompts_list = []

    for example in data:
        prompt_template = example['requested_rewrite']['prompt']
        subject = example['requested_rewrite']['subject']

        if '{}' in prompt_template:
            question = prompt_template.format(subject)
        else:
            question = prompt_template

        positive = example['requested_rewrite']['target_true']['str']
        negative = example['requested_rewrite']['target_new']['str']

        prompts_list.append({
            'question': question,
            'positive': positive,
            'negative': negative,
            'subject': subject
        })

    return [format_fact_prompt(prompt) for prompt in prompts_list]


def load_truthfulqa_dataset(split: str = "validation") -> List[Tuple[str, str]]:
    """Загрузка и форматирование TruthfulQA датасета."""
    truthfulqa = load_dataset("truthful_qa", "multiple_choice")

    pairs = []
    for entry in truthfulqa[split]:
        question = entry['question']
        mc2 = entry['mc2_targets']

        positive_answer = None
        negative_answer = None

        for choice, label in zip(mc2['choices'], mc2['labels']):
            if label == 1 and positive_answer is None:
                positive_answer = choice
            elif label == 0 and negative_answer is None:
                negative_answer = choice
            if positive_answer and negative_answer:
                break

        if positive_answer and negative_answer:
            SYSTEM_BLOCK = f"<<SYS>>\n{question}\n<</SYS>>"
            user_prompt = f"Choices: (A): {positive_answer} (B): {negative_answer}"
            final_prompt = f"<s> [INST] \n{SYSTEM_BLOCK}\n\n{user_prompt} [/INST] "

            pairs.append((final_prompt + "(A)", final_prompt + "(B)"))

    return pairs


def make_dataset(list_mwe_data: List[Dict[str, str]]) -> List[Tuple[str, str]]:
    """
    Создание датасета из данных sycophancy.
    """
    def make_pos_neg_pair(mwe_data: Dict[str, str]) -> Tuple[str, str]:
        B_INST = "[INST]"
        E_INST = "[/INST]"
        SYS_PROMPT = "You are a helpful, honest assistant."
        B_SYS = "<<SYS>>"
        E_SYS = "<</SYS>>"
        BOS_TOKEN = "<s>"
        prompt_template = f"{BOS_TOKEN} {B_INST} \n{B_SYS}{SYS_PROMPT}{E_SYS}\n\n {{question}} {E_INST} {{answer}}"

        pos = prompt_template.format(
            question=mwe_data["question"], answer=mwe_data["answer_matching_behavior"]
        )
        neg = prompt_template.format(
            question=mwe_data["question"], answer=mwe_data["answer_not_matching_behavior"]
        )
        return pos, neg

    return [make_pos_neg_pair(mwe_data) for mwe_data in list_mwe_data]


def prepare_toxicity_pairs(model, tokenizer, train_data, num_samples=100):
    """
    Подготовка токсичных/нетоксичных пар.
    """
    def format_one(prompt):
        BOS_TOKEN = "<s>"
        B_INST = "[INST]"
        E_INST = "[/INST]"
        B_SYS = "<<SYS>>"
        E_SYS = "<</SYS>>"

        SYSTEM_BLOCK = f"{B_SYS}\n{prompt['question']}\n{E_SYS}"
        user_prompt = f"Choices: (A): {prompt['positive']} (B): {prompt['negative']}"
        final_prompt = f"{BOS_TOKEN} {B_INST} \n{SYSTEM_BLOCK}\n\n{user_prompt} {E_INST} "

        return (final_prompt + "(A)", final_prompt + "(B)")

    def generate_response(model, tokenizer, prompt, max_length=400):
        inputs = tokenizer(prompt, return_tensors="pt").to(model.device)

        with torch.no_grad():
            outputs = model.generate(
                inputs.input_ids,
                max_new_tokens=max_length,
                do_sample=True,
                temperature=0.7,
                pad_token_id=tokenizer.eos_token_id,
            )

        response = tokenizer.decode(outputs[0][inputs.input_ids.shape[-1]:], skip_special_tokens=True)
        return response.split('\n')[0].strip()

    pairs = []

    for item in tqdm(train_data[:num_samples], desc="Creating pairs"):
        question = item['question'].strip()

        negative = generate_response(
            model, tokenizer,
            f"Give a response in a toxic way to: '{question[:400]}...' Response:",
            max_length=400
        )

        positive = generate_response(
            model, tokenizer,
            f"Give a polite response to: '{question[:400]}...' Response:",
            max_length=400
        )

        if positive and negative and len(positive) > 5 and len(negative) > 5:
            prompt_dict = {
                'question': question[:400],
                'positive': positive,
                'negative': negative
            }
            pairs.append(format_one(prompt_dict))

    return pairs